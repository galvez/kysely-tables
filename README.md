# kysely-tables

An attempt to give [Kysely]() the same level of DX from [Prisma]() and [Drizzle]().

Use the **same Kysely types** for your **SQL table schema**, **migrations** and **queries**.

- No need for an intermediary [schema defining API](https://orm.drizzle.team/docs/schemas) or [schema language](https://www.prisma.io/docs/orm/prisma-schema/overview).
- No need to [connect to the database to retrieve the schema structure](https://github.com/RobinBlomberg/kysely-codegen).
- No need to [bloat](https://github.com/drizzle-team/drizzle-kysely) [your](https://github.com/eoin-obrien/prisma-extension-kysely) [setup](https://github.com/valtyr/prisma-kysely) mixing multiple database libraries.

**Your Kysely types** become the **single source of truth** for your `CREATE TABLE` statements.

**And also** for **creating and running migrations**, very much like Prisma and Drizzle.

## Tutorial


## Syntax

<table>
<thead>
<tr>
<td><b>TypeScript</b></td>
<td><b>SQL</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>

`column: Default<string, "'member'">`

</td>
<td>

`"column" varchar(255) DEFAULT 'member' NOT NULL`

</td>
</tr>
</tbody>
</table>

## Internals

I wrote this because I was unhappy with the APIs and workflows available in other libraries. I wanted my database management layer to be extremely light, but also architected in an transparent way, that would make me feel like I know what's going behind the scenes.

> As a side note, this was a great example of the kind of utterly inefficient code generated by an LLM. The first boilerplate for this project was _vibe coded_ with Claude Sonnet 3.7, which amazingly gave me a semi-functional library. Upon inspection, I saw that it was using a glorious and recursive regex mess. It would first normalize the types (with the AST parser) and then proceed to use regexes to extract the type information, **again**. Don't worry, **I refactored it to exhaustion, no stone left unturned**. Now type extraction relies fully on the AST parser. To be fair, the insights I had from the LLM version were incredibly helpful, and the refactoring was very rewarding.

The main class is `KyselyTables`, which provides the `buildSchema()`, `buildSchemaReset()` and `buildSchemaRevision()` methods. The main code that analyzes the table interfaces and their column fields is `#registerTableColumns()`. They all use [TypeScript's compiler API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API) to properly parse the source file, no regexes involved. The whole API is heavily inspired by Kysely, and of course, compatible with Kysely â€” the special types serve as hints for schema generation, but Kysely gets what it's expecting:

```ts
export type Unique<T> = T
export type Default<T, _V> = T
export type Primary<T> = T
export type Sized<T, _Size extends number> = T
```

The main class uses a `DialectAdapter` to generate the correct SQL statements for the database used. 

As for parsing each column definition, it's done by a helper function called `extractType()`, which will check for all special types and use them to populate flags in each `ColumnDefinition`.

This should be enough for you to start digging and contribute if you wish!

## License

MIT


